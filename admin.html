<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>icecoast admin - manual updates</title>
  <style>
    :root {
      --bg: #f4f7fb;
      --card: #ffffff;
      --ink: #111827;
      --muted: #5b6472;
      --line: #d8dee8;
      --blue: #1e5eff;
      --blue-dark: #1144c6;
      --green: #0f8a5f;
      --danger: #c0362c;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
    }
    .wrap {
      max-width: 1060px;
      margin: 0 auto;
      padding: 1.25rem 1rem 2rem;
    }
    h1 {
      margin: 0 0 .35rem;
      font-size: 1.4rem;
      letter-spacing: .01em;
    }
    .sub {
      margin: 0 0 1rem;
      color: var(--muted);
      font-size: .92rem;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: .78rem;
      box-shadow: 0 8px 20px rgba(17, 24, 39, .04);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: .5rem;
      margin-bottom: .48rem;
    }
    .row-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: .5rem;
      margin-bottom: .48rem;
    }
    .row-4 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: .5rem;
      margin-bottom: .48rem;
    }
    label {
      display: block;
      font-size: .76rem;
      text-transform: uppercase;
      letter-spacing: .05em;
      color: var(--muted);
      margin-bottom: .2rem;
      font-weight: 700;
    }
    input, select, textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: .45rem .56rem;
      font-size: .88rem;
      background: #fff;
      color: var(--ink);
    }
    textarea {
      min-height: 220px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: .82rem;
      line-height: 1.35;
    }
    .btns {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem;
      margin-top: .65rem;
    }
    button {
      border: 0;
      border-radius: 8px;
      padding: .55rem .8rem;
      font-weight: 700;
      cursor: pointer;
      font-size: .86rem;
    }
    .primary { background: var(--blue); color: #fff; }
    .primary:hover { background: var(--blue-dark); }
    .good { background: var(--green); color: #fff; }
    .outline {
      background: #fff;
      color: #17202e;
      border: 1px solid var(--line);
    }
    .danger {
      background: #fff4f3;
      color: var(--danger);
      border: 1px solid #f0cbc6;
    }
    .danger-soft {
      background: #fff7ed;
      color: #9a3412;
      border: 1px solid #fed7aa;
    }
    .meta {
      margin-top: .45rem;
      font-size: .82rem;
      color: var(--muted);
    }
    .status {
      margin-top: .65rem;
      font-size: .84rem;
      font-weight: 700;
    }
    .status.ok { color: var(--green); }
    .status.warn { color: #8a5a0f; }
    .pill {
      display: inline-block;
      padding: .12rem .45rem;
      border-radius: 999px;
      background: #ffe9e7;
      color: #a1241b;
      border: 1px solid #f3c9c4;
      font-size: .72rem;
      margin-left: .45rem;
      font-weight: 700;
    }
    .manual-lifts-banner {
      display: none;
      margin: .12rem 0 .45rem;
      padding: .4rem .55rem;
      border-radius: 8px;
      border: 1px solid #fed7aa;
      background: #fff7ed;
      color: #9a3412;
      font-size: .78rem;
      font-weight: 700;
      letter-spacing: .01em;
    }
    .manual-lifts-banner.show {
      display: block;
    }
    .split {
      display: grid;
      grid-template-columns: 1.45fr .95fr;
      gap: .7rem;
    }
    @media (max-width: 920px) {
      .split, .row, .row-3, .row-4 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>icecoast Manual Update Panel</h1>
    <p class="sub">Update morning manual data (conditions, trails/lifts, 24h/48h snow), then export one <code>manual-data.js</code> file and upload it to GitHub.</p>

    <div class="split">
      <section class="card">
        <div class="row">
          <div>
            <label for="resortSelect">Resort</label>
            <select id="resortSelect"></select>
          </div>
          <div>
            <label for="regionView">Region</label>
            <input id="regionView" type="text" disabled />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="liftieView">Liftie API</label>
            <input id="liftieView" type="text" disabled />
          </div>
          <div>
            <label for="conditions">Current Conditions</label>
            <select id="conditions">
              <option value="">Select condition...</option>
              <option value="Powder">Powder</option>
              <option value="Packed Powder">Packed Powder</option>
              <option value="Snow Groomed">Snow Groomed</option>
              <option value="Machine Groomed">Machine Groomed</option>
              <option value="Variable">Variable</option>
              <option value="Hardpack">Hardpack</option>
              <option value="Firm">Firm</option>
              <option value="Frozen Granular">Frozen Granular</option>
              <option value="Granular">Granular</option>
              <option value="Loose Granular">Loose Granular</option>
              <option value="Spring Corn">Spring Corn</option>
              <option value="Wet / Heavy">Wet / Heavy</option>
              <option value="Arctic Blast ⚠️">Arctic Blast ⚠️</option>
              <option value="Thin Cover">Thin Cover</option>
              <option value="Icy in Spots">Icy in Spots</option>
              <option value="Mixed Conditions">Mixed Conditions</option>
            </select>
          </div>
        </div>
        <div id="manualLiftsBanner" class="manual-lifts-banner">Manual lift update required for this resort (Liftie not available).</div>

        <div class="row-4">
          <div>
            <label for="icecoastRating">Icecoast Rating (1-5)</label>
            <input id="icecoastRating" type="number" min="1" max="5" step="1" />
          </div>
          <div>
            <label for="trailsOpen">Trails Open</label>
            <input id="trailsOpen" type="number" min="0" step="1" />
          </div>
          <div>
            <label for="liftsOpen">Lifts Open</label>
            <input id="liftsOpen" type="number" min="0" step="1" />
          </div>
          <div>
            <label for="liftsTotal">Lifts Total</label>
            <input id="liftsTotal" type="number" min="0" step="1" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="snow24">24h Snow (inches, accepts cm)</label>
            <input id="snow24" type="text" inputmode="decimal" placeholder='12 or 30cm' />
          </div>
          <div>
            <label for="snow48">48h Snow (inches, accepts cm)</label>
            <input id="snow48" type="text" inputmode="decimal" placeholder='20 or 50cm' />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="weekdayTicket">Lift Ticket (weekday)</label>
            <input id="weekdayTicket" type="text" placeholder="$89 or $89+" />
          </div>
          <div>
            <label for="weekendTicket">Lift Ticket (weekend/peak)</label>
            <input id="weekendTicket" type="text" placeholder="$99 or $99+" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="parking">Parking</label>
            <input id="parking" type="text" placeholder="Free or $20" />
          </div>
          <div>
            <label for="dynamicPricing">Dynamic Pricing</label>
            <select id="dynamicPricing">
              <option value="false">No</option>
              <option value="true">Yes (show red Dynamic badge)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label for="trailsClosed">Trails Closed</label>
            <input id="trailsClosed" type="number" min="0" step="1" />
          </div>
          <div>
            <label for="vertical">Vertical Drop (ft)</label>
            <input id="vertical" type="number" min="0" step="1" />
          </div>
        </div>

        <div class="row">
          <div>
            <label for="apres">Après (0-5)</label>
            <input id="apres" type="number" min="0" max="5" step="1" />
          </div>
          <div>
            <label for="family">Family (0-5)</label>
            <input id="family" type="number" min="0" max="5" step="1" />
          </div>
        </div>

        <div class="btns">
          <button class="primary" id="saveResortBtn">Save This Resort</button>
          <button class="outline" id="saveNextBtn">Save + Next Resort</button>
          <button class="danger" id="clearResortBtn">Clear This Resort Override</button>
          <button class="danger-soft" id="resetSignalBtn">Reset Slope Signal (This Resort)</button>
        </div>
        <div class="meta" id="resortMeta"></div>
        <div class="status" id="editStatus"></div>
      </section>

      <section class="card">
        <label for="exportText">Generated manual-data.js</label>
        <textarea id="exportText" readonly></textarea>
        <div class="btns">
          <button class="good" id="downloadBtn">Download manual-data.js</button>
          <button class="outline" id="copyBtn">Copy to Clipboard</button>
          <button class="outline" id="refreshBtn">Refresh Output</button>
          <button class="primary" id="openConditionsBtn">Open Conditions Tabs</button>
        </div>
        <div class="meta">
          Upload this file to:
          <code>manual-data.js</code>
          <br />
          Then commit to GitHub and redeploy. Legacy <code>snowfall7d</code> keys are auto-removed on export.
        </div>
        <div class="status" id="exportStatus"></div>
      </section>
    </div>
  </div>

  <script src="resorts.js"></script>
  <script src="manual-data.js"></script>
  <script>
    const resorts = Array.isArray(window.RESORTS) ? window.RESORTS.slice() : [];
    const tierGroups = [
      {
        label: 'Tier 1 - Daily Full',
        ids: [
          'killington', 'stowe', 'sugarbush', 'stratton', 'mount-snow', 'okemo', 'jay-peak',
          'smugglers-notch', 'sunday-river', 'sugarloaf', 'loon', 'whiteface', 'hunter',
          'windham', 'gore-mountain', 'tremblant', 'camelback', 'blue-mountain'
        ]
      },
      {
        label: 'Tier 2 - Lite / Every Other Day Full',
        ids: [
          'pico', 'mad-river-glen', 'burke', 'cannon', 'wildcat', 'waterville', 'brettonwoods',
          'sunapee', 'pats-peak', 'ragged-mountain', 'belleayre', 'plattekill', 'jiminy-peak', 'wachusett',
          'catamount', 'berkshire-east', 'bolton-valley', 'saddleback', 'mont-sainte-anne',
          'le-massif', 'mont-sutton'
        ]
      },
      {
        label: 'Tier 3 - Exceptions / Weekend Focus',
        ids: [
          'jack-frost', 'big-boulder', 'shawnee', 'bear-creek', 'elk', 'montage', 'mohawk',
          'black-mountain', 'magic-mountain'
        ]
      }
    ];
    const overrides = JSON.parse(JSON.stringify(window.MANUAL_RESORT_OVERRIDES || {}));
    const resortsById = new Map(resorts.map(r => [r.id, r]));
    const ADMIN_REGION_LABELS = {
      'poconos': 'Pennsylvania',
      'catskills': 'New York',
      'adirondacks': 'New York',
      'massachusetts': 'Massachusetts',
      'connecticut': 'Connecticut',
      'vermont-south': 'Vermont (South)',
      'vermont-central': 'Vermont (Central)',
      'vermont-north': 'Vermont (North)',
      'white-mountains': 'New Hampshire',
      'maine': 'Maine',
      'canada': 'Canada'
    };

    function getTierRankMap() {
      const tierRank = {};
      tierGroups.forEach((group, idx) => {
        group.ids.forEach((id) => {
          tierRank[id] = idx;
        });
      });
      return tierRank;
    }

    const tierRankById = getTierRankMap();
    const orderedResorts = resorts.slice().sort((a, b) => {
      const aRank = tierRankById[a.id] ?? 999;
      const bRank = tierRankById[b.id] ?? 999;
      if (aRank !== bRank) return aRank - bRank;
      return a.name.localeCompare(b.name);
    });

    const el = {
      resortSelect: document.getElementById('resortSelect'),
      regionView: document.getElementById('regionView'),
      liftieView: document.getElementById('liftieView'),
      manualLiftsBanner: document.getElementById('manualLiftsBanner'),
      conditions: document.getElementById('conditions'),
      icecoastRating: document.getElementById('icecoastRating'),
      apres: document.getElementById('apres'),
      family: document.getElementById('family'),
      vertical: document.getElementById('vertical'),
      weekdayTicket: document.getElementById('weekdayTicket'),
      weekendTicket: document.getElementById('weekendTicket'),
      parking: document.getElementById('parking'),
      dynamicPricing: document.getElementById('dynamicPricing'),
      trailsOpen: document.getElementById('trailsOpen'),
      trailsClosed: document.getElementById('trailsClosed'),
      liftsOpen: document.getElementById('liftsOpen'),
      liftsTotal: document.getElementById('liftsTotal'),
      snow24: document.getElementById('snow24'),
      snow48: document.getElementById('snow48'),
      saveResortBtn: document.getElementById('saveResortBtn'),
      saveNextBtn: document.getElementById('saveNextBtn'),
      clearResortBtn: document.getElementById('clearResortBtn'),
      resetSignalBtn: document.getElementById('resetSignalBtn'),
      resortMeta: document.getElementById('resortMeta'),
      editStatus: document.getElementById('editStatus'),
      exportText: document.getElementById('exportText'),
      downloadBtn: document.getElementById('downloadBtn'),
      copyBtn: document.getElementById('copyBtn'),
      refreshBtn: document.getElementById('refreshBtn'),
      openConditionsBtn: document.getElementById('openConditionsBtn'),
      exportStatus: document.getElementById('exportStatus')
    };
    let loadedFormSnapshot = '';
    let currentResortId = null;

    const ADMIN_STORAGE = {
      workerUrl: 'icecoast_admin_worker_url',
      adminToken: 'icecoast_admin_token'
    };

    function setStatus(node, text, cls) {
      node.textContent = text || '';
      node.className = `status ${cls || ''}`.trim();
    }

    function getSavedAdminConfig() {
      let workerUrl = '';
      let adminToken = '';
      try {
        workerUrl = localStorage.getItem(ADMIN_STORAGE.workerUrl) || '';
        adminToken = localStorage.getItem(ADMIN_STORAGE.adminToken) || '';
      } catch (_) {}
      return { workerUrl, adminToken };
    }

    function saveAdminConfig(workerUrl, adminToken) {
      try {
        if (workerUrl) localStorage.setItem(ADMIN_STORAGE.workerUrl, workerUrl);
        if (typeof adminToken === 'string') localStorage.setItem(ADMIN_STORAGE.adminToken, adminToken);
      } catch (_) {}
    }

    function promptForAdminConfig() {
      const saved = getSavedAdminConfig();
      const workerPrompt = saved.workerUrl || 'https://YOUR-WORKER-SUBDOMAIN.workers.dev';
      const workerUrlInput = prompt('Enter your Cloudflare Worker URL (no trailing slash):', workerPrompt);
      if (!workerUrlInput) return null;
      const workerUrl = workerUrlInput.trim().replace(/\/+$/, '');
      if (!/^https?:\/\//i.test(workerUrl)) {
        alert('Worker URL must start with http:// or https://');
        return null;
      }
      const tokenPrompt = saved.adminToken || '';
      const adminTokenInput = prompt('Enter ADMIN_HEALTH_TOKEN (required for reset endpoints):', tokenPrompt);
      if (adminTokenInput === null) return null;
      const adminToken = adminTokenInput.trim();
      saveAdminConfig(workerUrl, adminToken);
      return { workerUrl, adminToken };
    }

    async function resetSlopeSignalForCurrentResort() {
      const resort = getCurrentResort();
      if (!resort) return;

      const confirmed = confirm(`Reset Slope Signal votes for ${resort.name}? This cannot be undone.`);
      if (!confirmed) return;

      let cfg = getSavedAdminConfig();
      if (!cfg.workerUrl || !cfg.adminToken) {
        const prompted = promptForAdminConfig();
        if (!prompted) {
          setStatus(el.editStatus, 'Reset canceled.', 'warn');
          return;
        }
        cfg = prompted;
      }

      el.resetSignalBtn.disabled = true;
      const originalText = el.resetSignalBtn.textContent;
      el.resetSignalBtn.textContent = 'Resetting...';

      try {
        const endpoint = new URL('/admin/sendit/reset', cfg.workerUrl);
        endpoint.searchParams.set('resortId', resort.id);
        const resp = await fetch(endpoint.toString(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Admin-Token': cfg.adminToken
          }
        });
        const payload = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          if (resp.status === 401) {
            const refresh = promptForAdminConfig();
            if (refresh) setStatus(el.editStatus, 'Token updated. Click reset again.', 'warn');
            else setStatus(el.editStatus, 'Reset failed: unauthorized.', 'warn');
            return;
          }
          throw new Error(payload?.error || `Reset failed (${resp.status})`);
        }
        setStatus(el.editStatus, `Slope Signal reset for ${resort.name}.`, 'ok');
      } catch (err) {
        setStatus(el.editStatus, `Reset failed: ${err.message}`, 'warn');
      } finally {
        el.resetSignalBtn.disabled = false;
        el.resetSignalBtn.textContent = originalText;
      }
    }

    function numberOrNull(value) {
      if (value === '' || value === null || typeof value === 'undefined') return null;
      const n = Number(value);
      return Number.isFinite(n) ? n : null;
    }

    function parseSnowfallToInchesOrNull(value) {
      const raw = cleanString(String(value ?? ''));
      if (!raw) return null;
      const normalized = raw.toLowerCase().replace(',', '.');
      const match = normalized.match(/-?\d+(\.\d+)?/);
      if (!match) return null;
      const amount = Number(match[0]);
      if (!Number.isFinite(amount)) return null;
      const isCm = /\bcm\b|centimet|centimeter|centimetre/.test(normalized);
      return isCm ? (amount / 2.54) : amount;
    }

    function normalizeSnowInputInches(inputEl) {
      if (!inputEl) return;
      const parsed = parseSnowfallToInchesOrNull(inputEl.value);
      if (parsed === null) return;
      inputEl.value = String(Math.max(0, Math.round(parsed)));
    }

    function stableStringify(value) {
      if (Array.isArray(value)) {
        return `[${value.map(stableStringify).join(',')}]`;
      }
      if (value && typeof value === 'object') {
        const keys = Object.keys(value).sort();
        return `{${keys.map((k) => `${JSON.stringify(k)}:${stableStringify(value[k])}`).join(',')}}`;
      }
      return JSON.stringify(value);
    }

    function cleanString(value) {
      if (typeof value !== 'string') return '';
      return value.trim();
    }

    function setConditionSelectValue(value) {
      const normalized = cleanString(value);
      Array.from(el.conditions.options)
        .filter((opt) => opt.dataset.custom === 'true')
        .forEach((opt) => opt.remove());
      if (!normalized) {
        el.conditions.value = '';
        return;
      }

      const hasMatch = Array.from(el.conditions.options).some(opt => opt.value === normalized);
      if (!hasMatch) {
        const custom = document.createElement('option');
        custom.value = normalized;
        custom.textContent = `${normalized} (custom)`;
        custom.dataset.custom = 'true';
        el.conditions.appendChild(custom);
      }
      el.conditions.value = normalized;
    }

    function hasLiftieCoverage(resort) {
      return !!(resort && typeof resort.liftie === 'string' && resort.liftie !== 'null');
    }

    function formatAdminRegion(regionKey) {
      if (!regionKey) return '';
      return ADMIN_REGION_LABELS[regionKey] || regionKey;
    }

    function getCurrentResort() {
      const id = el.resortSelect.value;
      return resorts.find(r => r.id === id) || null;
    }

    function getResortOptionMarkup(resort) {
      return `<option value="${resort.id}">${resort.name}${hasLiftieCoverage(resort) ? '' : ' (manual lifts)'}</option>`;
    }

    function populateResortSelect() {
      const groupMarkup = tierGroups.map((group) => {
        const options = group.ids
          .map((id) => resortsById.get(id))
          .filter(Boolean)
          .map((resort) => getResortOptionMarkup(resort))
          .join('');
        if (!options) return '';
        return `<optgroup label="${group.label}">${options}</optgroup>`;
      }).join('');

      const unassigned = orderedResorts
        .filter((resort) => typeof tierRankById[resort.id] === 'undefined')
        .map((resort) => getResortOptionMarkup(resort))
        .join('');

      el.resortSelect.innerHTML = unassigned
        ? `${groupMarkup}<optgroup label="Unassigned">${unassigned}</optgroup>`
        : groupMarkup;
    }

    function loadFormForResort(resortId) {
      const resort = resorts.find(r => r.id === resortId);
      if (!resort) return;
      const patch = overrides[resortId] || {};
      const liftieEnabled = hasLiftieCoverage(resort);

      el.regionView.value = formatAdminRegion(resort.region);
      el.liftieView.value = liftieEnabled ? `Yes (${resort.liftie})` : 'No (manual lift input recommended)';
      el.manualLiftsBanner.classList.toggle('show', !liftieEnabled);
      setConditionSelectValue(patch.conditions ?? '');
      el.icecoastRating.value = patch.icecoastRating ?? '';
      el.apres.value = patch.apres ?? '';
      el.family.value = patch.family ?? '';
      el.vertical.value = patch.vertical ?? '';
      el.weekdayTicket.value = patch.liftTicket?.weekday ?? '';
      el.weekendTicket.value = patch.liftTicket?.weekend ?? '';
      el.parking.value = patch.parking ?? '';
      el.dynamicPricing.value = patch.dynamicPricing ? 'true' : 'false';
      el.trailsOpen.value = patch.trails?.open ?? '';
      el.trailsClosed.value = patch.trails?.closed ?? '';
      el.liftsOpen.value = patch.lifts?.open ?? '';
      el.liftsTotal.value = patch.lifts?.total ?? resort.liftsTotal ?? '';
      el.snow24.value = patch.snowfall24h ?? '';
      el.snow48.value = patch.snowfall48h ?? '';

      const isEdited = !!overrides[resortId];
      el.resortMeta.innerHTML = isEdited
        ? `Editing <strong>${resort.name}</strong> <span class="pill">Override saved</span> ${liftieEnabled ? '' : '<span class="pill">Manual lifts</span>'}`
        : `Editing <strong>${resort.name}</strong>${liftieEnabled ? '' : ' <span class="pill">Manual lifts</span>'}`;

      currentResortId = resortId;
      loadedFormSnapshot = stableStringify(sanitizePatchForExport(buildPatchFromForm()));
    }

    function buildPatchFromForm() {
      const patch = {};
      const conditions = cleanString(el.conditions.value);
      if (conditions) patch.conditions = conditions;

      const rating = numberOrNull(el.icecoastRating.value);
      if (rating !== null) patch.icecoastRating = Math.max(1, Math.min(5, Math.round(rating)));

      const apres = numberOrNull(el.apres.value);
      if (apres !== null) patch.apres = Math.max(0, Math.min(5, Math.round(apres)));

      const family = numberOrNull(el.family.value);
      if (family !== null) patch.family = Math.max(0, Math.min(5, Math.round(family)));

      const vertical = numberOrNull(el.vertical.value);
      if (vertical !== null) patch.vertical = Math.max(0, Math.round(vertical));

      const weekday = cleanString(el.weekdayTicket.value);
      const weekend = cleanString(el.weekendTicket.value);
      if (weekday || weekend) {
        patch.liftTicket = {
          weekday: weekday || weekend,
          weekend: weekend || weekday
        };
      }

      const parking = cleanString(el.parking.value);
      if (parking) patch.parking = parking;

      patch.dynamicPricing = el.dynamicPricing.value === 'true';

      const trailsOpen = numberOrNull(el.trailsOpen.value);
      const trailsClosed = numberOrNull(el.trailsClosed.value);
      if (trailsOpen !== null || trailsClosed !== null) {
        patch.trails = {};
        if (trailsOpen !== null) patch.trails.open = Math.max(0, Math.round(trailsOpen));
        if (trailsClosed !== null) patch.trails.closed = Math.max(0, Math.round(trailsClosed));
      }

      const liftsOpen = numberOrNull(el.liftsOpen.value);
      const liftsTotal = numberOrNull(el.liftsTotal.value);
      if (liftsOpen !== null || liftsTotal !== null) {
        patch.lifts = {};
        if (liftsOpen !== null) patch.lifts.open = Math.max(0, Math.round(liftsOpen));
        if (liftsTotal !== null) patch.lifts.total = Math.max(0, Math.round(liftsTotal));
      }

      const snow24 = parseSnowfallToInchesOrNull(el.snow24.value);
      if (snow24 !== null) patch.snowfall24h = Math.max(0, Math.round(snow24));
      const snow48 = parseSnowfallToInchesOrNull(el.snow48.value);
      if (snow48 !== null) patch.snowfall48h = Math.max(0, Math.round(snow48));

      return patch;
    }

    function isPatchEmpty(patch) {
      return !patch || Object.keys(patch).length === 0;
    }

    function sanitizePatchForExport(patch) {
      const clean = JSON.parse(JSON.stringify(patch || {}));
      delete clean.snowfall7d;
      return clean;
    }

    function savePatchForResortId(resortId, options = {}) {
      const resort = resortsById.get(resortId);
      if (!resort) return false;
      const patch = buildPatchFromForm();
      if (isPatchEmpty(patch)) {
        delete overrides[resort.id];
      } else {
        patch._patrolUpdatedAt = new Date().toISOString();
        overrides[resort.id] = patch;
      }
      renderExportText();
      if (!options.silent) {
        loadFormForResort(resort.id);
        setStatus(el.editStatus, `Saved ${resort.name}.`, 'ok');
      }
      return true;
    }

    function saveCurrentResort() {
      const resort = getCurrentResort();
      if (!resort) return;
      savePatchForResortId(resort.id);
    }

    function hasUnsavedResortChanges() {
      if (!currentResortId) return false;
      const currentSnapshot = stableStringify(sanitizePatchForExport(buildPatchFromForm()));
      return currentSnapshot !== loadedFormSnapshot;
    }

    function goToNextResort() {
      const idx = el.resortSelect.selectedIndex;
      const total = el.resortSelect.options.length;
      if (!total) return;
      const next = (idx + 1) % total;
      el.resortSelect.selectedIndex = next;
      loadFormForResort(el.resortSelect.value);
    }

    function renderExportText() {
      const sorted = {};
      orderedResorts.forEach(r => {
        if (overrides[r.id]) sorted[r.id] = sanitizePatchForExport(overrides[r.id]);
      });
      const out = [
        '/*',
        ' * ICECOAST manual resort overrides',
        ' * Generated from admin.html',
        ' */',
        `window.MANUAL_RESORT_OVERRIDES_META = ${JSON.stringify({ updatedAt: new Date().toISOString() }, null, 2)};`,
        `window.MANUAL_RESORT_OVERRIDES = ${JSON.stringify(sorted, null, 2)};`,
        ''
      ].join('\n');
      el.exportText.value = out;
      setStatus(el.exportStatus, `${Object.keys(sorted).length} resorts with manual overrides.`, 'warn');
    }

    function downloadExport() {
      const text = el.exportText.value;
      const blob = new Blob([text], { type: 'application/javascript;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'manual-data.js';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus(el.exportStatus, 'Downloaded manual-data.js', 'ok');
    }

    async function copyExport() {
      try {
        await navigator.clipboard.writeText(el.exportText.value);
        setStatus(el.exportStatus, 'Copied JS to clipboard.', 'ok');
      } catch (e) {
        setStatus(el.exportStatus, 'Clipboard copy failed. Use download instead.', 'warn');
      }
    }

    const CONDITIONS_URL_BY_RESORT = {
      'camelback': 'https://conditions.camelbackresort.com/conditions/snow-report/',
      'blue-mountain': 'https://www.skibluemt.com/winter-sports/skiing-snowboarding/',
      'jack-frost': 'https://www.jfbb.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'shawnee': 'https://www.shawneemt.com/snow-report/',
      'bear-creek': 'https://www.bcmountainresort.com/activities/ski-snowboarding/ski-conditions/',
      'elk': 'https://www.elkskier.com/conditions/',
      'big-boulder': 'https://www.jfbb.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'montage': 'https://www.montagemountainresorts.com/trails/',
      'hunter': 'https://www.huntermtn.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'windham': 'https://www.windhammountainclub.com/mountain-report/',
      'belleayre': 'https://www.belleayre.com/mountain/snow-report/',
      'plattekill': 'https://plattekill.com/conditions-report/',
      'whiteface': 'https://whiteface.com/mountain/conditions/',
      'gore-mountain': 'https://goremountain.com/the-mountain/conditions/',
      'jiminy-peak': 'https://www.jiminypeak.com/the-mountain/mountain-information/snow-report/',
      'wachusett': 'https://www.wachusett.com/the-mountain/your-visit/snow-report/',
      'catamount': 'https://www.catamountski.com/mountain-report/',
      'berkshire-east': 'https://berkshireeast.com/snow-report',
      'mohawk': 'https://www.mohawkmtn.com/snow-report/',
      'stratton': 'https://www.stratton.com/the-mountain/mountain-report',
      'mount-snow': 'https://www.mountsnow.com/ski-ride/snow-report/',
      'killington': 'https://www.killington.com/the-mountain/conditions-weather/current-conditions-weather/',
      'okemo': 'https://www.okemo.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'pico': 'https://map.picomountain.com/conditions/snow-report/printable-report/',
      'sugarbush': 'https://www.sugarbush.com/mountain/conditions',
      'mad-river-glen': 'https://www.madriverglen.com/conditions/',
      'stowe': 'https://www.stowe.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'smugglers-notch': 'https://www.smuggs.com/conditions/winter-report',
      'jay-peak': 'https://digital.jaypeakresort.com/conditions/snow-report/',
      'burke': 'https://skiburke.com/the-mountain/weather-conditions/',
      'bolton-valley': 'https://www.boltonvalley.com/winter/snow-conditions/',
      'loon': 'https://www.loonmtn.com/mountain-report',
      'brettonwoods': 'https://www.brettonwoods.com/snow-trail-report/',
      'waterville': 'https://www.waterville.com/snow-report-maps/',
      'cannon': 'https://www.cannonmt.com/mountain-report',
      'wildcat': 'https://www.skiwildcat.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'black-mountain': 'https://blackmt.com/snow-report/',
      'ragged-mountain': 'https://raggedmountainresort.com/mountain-report/',
      'sunapee': 'https://www.mountsunapee.com/the-mountain/mountain-conditions/snow-and-weather-report.aspx',
      'pats-peak': 'https://www.patspeak.com/snow-report/',
      'magic-mountain': 'https://magicmtn.com/snow-report/',
      'sunday-river': 'https://www.sundayriver.com/mountain-report',
      'sugarloaf': 'https://www.sugarloaf.com/mountain-report',
      'saddleback': 'https://www.saddlebackmaine.com/mountain-report/',
      'tremblant': 'https://www.tremblant.ca/mountain-village/mountain-report',
      'mont-sainte-anne': 'https://mont-sainte-anne.com/en/alpine-skiing-snow-conditions/',
      'le-massif': 'https://www.lemassif.com/fr/montagne/hiver/neige-meteo-et-webcams/',
      'mont-sutton': 'https://montsutton.com/en/the-mountain/ski-conditions-2/'
    };

    function getDropdownOrderResorts() {
      const byId = new Map(resorts.map(r => [r.id, r]));
      const ordered = [];
      const seen = new Set();

      tierGroups.forEach((group) => {
        group.ids.forEach((id) => {
          const resort = byId.get(id);
          if (!resort || seen.has(id)) return;
          seen.add(id);
          ordered.push(resort);
        });
      });

      resorts
        .filter((r) => !seen.has(r.id))
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((r) => ordered.push(r));

      return ordered;
    }

    function buildConditionsUrls() {
      const urls = [];
      const seen = new Set();
      const dropdownOrdered = getDropdownOrderResorts();
      dropdownOrdered.forEach((resort) => {
        if (!resort || !resort.id || seen.has(resort.id)) return;
        seen.add(resort.id);
        const direct = CONDITIONS_URL_BY_RESORT[resort.id];
        if (direct) {
          urls.push(direct);
        } else {
          const q = encodeURIComponent(`${resort.name} ski resort snow report`);
          urls.push(`https://www.google.com/search?q=${q}`);
        }
      });
      return urls;
    }

    async function openConditionsTabs() {
      const urls = buildConditionsUrls();
      if (!urls.length) {
        setStatus(el.exportStatus, 'No resort URLs found.', 'warn');
        return;
      }

      let opened = 0;
      for (let i = 0; i < urls.length; i += 1) {
        const win = window.open(urls[i], '_blank');
        if (win) opened += 1;
        // Preserve strict left-to-right tab order in Brave.
        await new Promise((resolve) => setTimeout(resolve, 90));
      }

      if (opened === 0) {
        setStatus(el.exportStatus, 'Popup blocker stopped tabs. Allow popups for this page and click again.', 'warn');
      } else if (opened < urls.length) {
        setStatus(el.exportStatus, `Opened ${opened}/${urls.length} tabs. Allow popups for all tabs.`, 'warn');
      } else {
        setStatus(el.exportStatus, `Opened ${opened} condition tabs in admin order.`, 'ok');
      }
    }

    el.resortSelect.addEventListener('change', () => {
      const nextResortId = el.resortSelect.value;
      if (currentResortId && nextResortId !== currentResortId && hasUnsavedResortChanges()) {
        const resort = resortsById.get(currentResortId);
        const shouldSave = confirm(`Unsaved changes for ${resort?.name || 'current resort'}. Save before switching?`);
        if (shouldSave) {
          savePatchForResortId(currentResortId, { silent: true });
        } else {
          setStatus(el.editStatus, `Switched resorts without saving ${resort?.name || 'previous edits'}.`, 'warn');
        }
      }
      loadFormForResort(nextResortId);
      if (!hasUnsavedResortChanges()) {
        setStatus(el.editStatus, '', '');
      }
    });

    el.snow24.addEventListener('blur', () => normalizeSnowInputInches(el.snow24));
    el.snow48.addEventListener('blur', () => normalizeSnowInputInches(el.snow48));
    el.saveResortBtn.addEventListener('click', saveCurrentResort);
    el.saveNextBtn.addEventListener('click', () => {
      saveCurrentResort();
      goToNextResort();
    });
    el.clearResortBtn.addEventListener('click', () => {
      const resort = getCurrentResort();
      if (!resort) return;
      delete overrides[resort.id];
      loadFormForResort(resort.id);
      renderExportText();
      setStatus(el.editStatus, `Cleared override for ${resort.name}.`, 'warn');
    });
    el.resetSignalBtn.addEventListener('click', resetSlopeSignalForCurrentResort);
    el.downloadBtn.addEventListener('click', downloadExport);
    el.copyBtn.addEventListener('click', copyExport);
    el.refreshBtn.addEventListener('click', renderExportText);
    el.openConditionsBtn.addEventListener('click', openConditionsTabs);

    populateResortSelect();
    if (el.resortSelect.options.length > 0) {
      loadFormForResort(el.resortSelect.value);
    }
    renderExportText();
  </script>
</body>
</html>
